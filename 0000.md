# 自我介绍

您好，我叫xxx，来自xxx。毕业于东华理工大学目前有两年的工作经验，熟悉Spring，MyBatis等框架。有着丰富的erp管理系统架构的经验。在上家公司也从事这方面的工作。业余时间我也搭建过自己的博客，写过很多小项目。为了方便工作效率，我也会去写一些小工具，如代码自动生成，邮件自动生成及发送。目前同事都在用我写的工具。生活上我比较积极乐观，一般比较喜欢看电影来放松。我的自我介绍完了，谢谢！！！



# 项目

资源配置项目：主是太平对项目进行管理平台。而每个项目包含，立项，预算，合同，订单，结算单等多个模块。我主要是项目架构的搭建和对外部系统的对接。

项目架构方面用到了Springboot+mybatisplus，前端使用了vue和elememt。

与外部系统对接：使用到了封装好的httpUtils的工具类。根据外部系统的要求对接他们，或者根据他们的要求写接口。

项目亮点：







产品通项目：这是一款介绍保险产品的app，主要功能是帮助用户更容易去了解产品。

主要的功能点有：计划书，产品库，产品属性等。

我主要做的就是计划书和产品属性：

计划书大部分就是配置数据库数据，然后前端根据具体业务要求去选择组件并引入页面。

产品属性目的就是将产品给













# jvm

###### jvm是什么：

jvm（Java Virtual Machine）java虚拟机

###### jvm的作用：

实现跨平台（将.class文件根据各操作系统对应的jvm编译成字节码在各操作系统运行）

###### jvm的内存划分：

- 类加载器：负责加载程序中的类
- 执行引擎：执行字节码或本地方法
- 运行时数据区：程序运行时数据区域

###### 类加载器：

​		负责类的加载，不管是否可以运行。

​		查找类过程：启动类加载器----->扩展类加载器----->应用程序类加载器----->用户自定义加载器

​		双亲委派机制：当子类加载器查找类时，会先让父类去查找这个类。（如果一个类加载器收到了加载类的请		求，它会先把请求委托给上层加载器去完成，上层加载器又会委托上上层加载器，一直到最顶层的类加载		器；如果上层加载器无法完成类的加载工作时，当前类加载器才会尝试自己去加载这个类。）

###### jvm运行时数据区：

- 程序计数器：

  工作过程：（线程私有）字节码解释器通过改变程序计数器的值来依次执行。

  作用：就是让代码顺序执行

- 虚拟机栈：

  工作过程：（线程私有）将java程序的每个方法作为栈帧都放入栈中，代码一行行读取，对应着一次次入栈。代码一行行执行对应这个一次次出栈。方法中的局部变量都会存在这个栈帧中。

  作用：区分每个方法的局部变量。并且让代码顺序执行

  栈帧会出现以下两种异常：

  StackOverFlowError（栈溢出）虚拟机栈的内存不允许动态扩容，当线程请求栈的深度超过虚拟机的最大深度时就会抛出该异常。（如递归死循环）：for(;;)  {method()};

  OutOfMemoryError（内存溢出）又叫oom，引发该异常的原因有两个：堆空间不足，元空间不足。一般由申请空间过大且无法被释放：for(;;)  {int[] tmp=new int[1000000]; list.add(tmp);};

- 本地方法栈：

  类似虚拟机栈，执行的是本地方法（本地方法就是非java代码的接口）。

- 堆：

  工作过程：（线程共享）占用最大资源的一块，所有对象的引用实例以及数组都在这哥区域分配内存

  作用：存储数据

  堆内存主要分为三块：

  新生代：内存满了会进行 minorGC，如果依然不够，会移动到老生代

  老生代：满了会进行FullGC,如果依然内存不够，会出现OOM(OutOfMemoryError)

  永生代（方法区）：1.8已被移除，后为元空间

  由于堆中存储各种内存，所有是主要GC（垃圾收集）的部分

- 元空间：

  作用：存放被虚拟机加载的类信息，常量池



# JMM

###### 什么是jmm：

规定线程和内存之间的一些关系：

java所以变量均在主存中，每个线程都有自己的工作内存。线程之间相互无法直接访问，变量传递需通过主存完成

jmm的三大特性：

- 原子性：多个线程一起执行，一个操作一旦开始就不能被其他线程干扰
- 可见性：共享变量的值被修改，其他线程也能看到
- 有序性：单个线程内的操作是有序的（指令重排会将代码执行顺序打乱）

# 集合

#### ArrayList和LinkedList区别？

相同点：

都是list的子类

都是有序且不安全的

不同点：

ArrayList是数组结构，有查询快，插入修改慢的特点

LinkedList是链表结构，有插入快，查询慢的特点



#### ArrayList扩容机制怎样？

ArrayList的默认容量为10，超过就会按照1.5倍进行扩容如：

第一次：10*1.5 = 15

第二次：15*1.5 = 22.5

......

可以设置初始容量来限制ArrayList的扩容

比如，我需要装载20个数字进入数组。

默认扩容后结果为：

第一次：10*1.5 = 15

第二次：15*1.5 = 22.5

设置初始容量后：List<Integer> list = new ArrayList<>(4);

第一次：4*1.5 = 6

第二次：6*1.5 = 9

第三次：9*1.5 = 13.5

第四次：13.5*1.5 = 20.25

结果可想而知，初始容量太小，扩容了4次，影响了性能。



#### HashMap和HashTable的区别？

相同点：

1.都是map的子类

2.都是key-value的结构，数组加链表的结构

不同点：

1.hashMap安全，hashTable不安全。所以一个快，一个慢

2.hashMap支持key有一个为空，value都可为空，hashTable支持key不能为空，value只能有一个为空



#### HashMap的工作原理

jdk1.7：使用的是数组+链表的结构。

jdk1.8：使用的是数组+链表+红黑树



1.7时：以计算key的hashCode值来决定放在哪个桶里（也就是数组）。初始的桶数量为16

当桶里的球（entry）数量超过阈值时（16*0.75）便会进行2倍扩容。

头插法：当发生hash碰撞时（也就是新的球进入了有球的桶里），便进行头插法（将新的球插入到第一个。这个球的尾巴连接下面球的头部）。

1.8时：使用红黑树对链表处结构进行改善，当链表大小超过8后就转为红黑树，优化了查询速度。

尾插法：当发生hash碰撞时：将这个球头部直接连接到最后一个球的尾巴。



综上，我觉得1.7的时候因为考虑到效率，所以直接将新的球放到第一个位置，这样就不需要去找到最后的球。以此提升效率。

1.8，在8个球内需查找到最后一个球，然后插入。当超过8个球，新的球就根据红黑树来决定排在哪个。



#### List、Set、Map三个接口的区别以及常见子类

区别：

list：有序，单列，可重复

set：单列，不可重复（linkedhashset有序，其他无序）

map：无序，双列，key不可重复，值可重复



子类：

list：arrayList，linkList，vector

set：hashSet，linkedHashSet，TreeSet

map：hashMap，hashTable，concurrentHashmap，LinkedHashMap，TreeMap



#### 是否了解ConcurrentHashMap？

concurrentHashMap有hashmap的基本特征：数组+链表+红黑树。而且key，value不能为空

但是它线程安全

jdk1.7：使用的是分段锁的设计。（segment）将所有的桶分成若干（一般是16）分，每一份都有若干个（HashEntry），而segment实现了ReentrantLock（重入锁区别于synchronized：synchronized在一个线程未获取到锁时就一直等着。而ReentrantLock可中断）。这个措施区别于hashTable的全部加锁。优化了太多。当多个线程操作这个一个Map资源时，不是相同的segment都可以有锁访问。

put的时候，先通过hashcode找到相应的segment，再找到相应的HashEntry，然后进入value的链表插入。

jdk1.8：CAS + synchronized + Node + 红黑树：put方法中锁住代码块。



hashMap与HashTable的区别：

hashMap不安全，但效率高

hashTable因为使用synchronized（同步锁）将整个数组都锁住了，所以安全，但是效率极低。



#### 是否了解LinkedHashMap：

LinkedHashMap在hashMap的基础上维护了一个双向链表，每次put的时候就在before和after记录前后插入的entry的位置。

![img](https://www.whfch.icu/resources/1a339d91-4cc4-410d-b366-dc28a432c124.png)

#### hashMap的扩容机制为什么是2的倍数

HashMap计算添加元素的位置时，使用的位运算，这是特别高效的运算；另外，HashMap的初始容量是2的n次幂，扩容也是2倍的形式进行扩容，是因为容量是2的n次幂，可以使得添加的元素均匀分布在HashMap中的数组上，减少hash碰撞，避免形成链表的结构，使得查询效率降低！



# 抽象类，接口：

抽象类特征：

- 抽象类是使用abstract修饰的，抽象方法也是
- 抽象类中可以有抽象方法，也可以没有抽象方法
- 抽象类的抽象方法只有方法体，无具体实现
- 抽象类无法被实例化
- 子类继承抽象类实现了父类的所有抽象方法，那么可以不必是抽象类。反之必然是抽象类

接口特征：

- 接口使用interface修饰，接口内的方法也是
- 接口中均为抽象方法且无具体实现
- 接口无法被实例化
- 一个类可以实现多个接口

区别：

- 抽象类内可以有非抽象方法及其具体实现，接口方法没有具体实现
- 抽象类的成员变量可以为各种类型，接口只能是public，static，final类型的
- 抽象类可以有静态方法及代码块，接口没有
- 一个类只能继承一个抽象类，但能实现多个接口



# 重载和重写？

不同点：

- 重载发生在一个类中，重写发生在父子类
- 重载的方法名必须一样，参数，返回值都可不同。重写参数必须相同且返回值类型相同或子类
- 访问权限，重载可修改，重写一定不能做更严格的限制（如父类方法为public，子类方法就不能是protected）



# 多线程

#### 线程

###### 线程是什么：

线程是操作系统调度的最小单元，也叫轻量级进程。他被包含在进程（进程是一个执行中的程序）中，是进程的实际运作单位。

###### 线程与进程：

- 线程是程序执行的最小单位，进程是操作系统分配资源的最小单位
- 一个进程由多个线程组成
- 线程上下文切换比进程上下文切换快的多

###### 实现线程的方法

- 继承Thread
- 实现runable
- 实现callable

```
public class xianchen {
    static class ThreadTest extends Thread {

        @Override
        public void run() {
            for(int i = 1; i <= 10; i++){
                System.out.println("ThreadTest"+"--"+i);
            }

        }
    }
    static class RunableTest implements Runnable {
        @Override
        public void run() {
            for(int i = 1; i <= 10; i++){
                System.out.println("runableTest"+"--"+i);
            }

        }
    }
    static class CallableTest implements Callable {
        @Override
        public Object call() throws Exception {
            for(int i = 1; i <= 10; i++){
                System.out.println("CallableTest"+"--"+i);
            }
            return null;
        }
    }
    public static void main(String[] args) {
        // ThreadTest
        ThreadTest threadTest = new ThreadTest();
        // RunableTest
        Thread runableTest = new Thread(new RunableTest());
        // CallableTest
        FutureTask futureTask = new FutureTask(new CallableTest());
        Thread callableTest = new Thread(futureTask);

        threadTest.start();
        runableTest.start();
        callableTest.start();
    }
}
```

###### 线程的几种状态：

- 创建（new）
- 就绪（Runnable）
- 运行（Running）
- 阻塞（Blocked）

1. 等待阻塞：运行的线程执行wait()方法，该线程会释放占用的所有资源，JVM会把该线程放入“**等待池”**中。进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用notify()或notifyAll()方法才能被唤醒，
2. 同步阻塞：同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入**“锁池”**中。
3. 其他阻塞：sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。

- 死亡（Dead）

###### Runable与Callable的区别：

- callable可以返回结果
- callable可以上抛异常，runable只能在run方法内部消化
- callable接口实现call方法，runable实现run方法

###### start（）与run（）的区别

start方法是启动线程的方法，run只是一个普通的方法

###### CyclicBarrier（栅栏） 和 CountDownLatch（倒计时锁）：

他们作用：让线程等待其他线程

相同点：让线程等待

不同点：CountdownLatch 不能重新使用

###### 如何让线程结束：

如果是从循环退出：定义一个volatile变量，然后改变这个变量，就能让改线程从循环中退出。

如果是线程不执行完，直接退出：thread.interrupt();

######  有三个线程T1，T2，T3，怎么确保它们按顺序执行

使用join方法

###### count++是原子操作吗？

不是，在多线程环境下需要使用同步，或者原子性修饰符（atomic ）

###### count = count++;结果为什么是0

- 1、JVM把count的初始值（即0）拷贝到临时变量区（栈stack）。
- 2、count值加1，此时count的值是1。
- 3、返回临时变量区的值，注意这个值是0，没有被修改过。
- 4、返回值赋值给count，此时count值被重置为0。

#### 线程池

###### 什么是线程池：

一个存放多个线程的池子

###### 为什么会有线程池：

减少线程的频繁创建和销毁带来的资源损耗。

###### 如何创建线程池：

```
        // 队列
        BlockingQueue<Runnable> bq = new ArrayBlockingQueue<Runnable>(10);
        // corePoolSize(核心线程数) maximumPoolSize（最大线程数）keepAliveTime（当线程数大于核心数时，这是多余空闲线程在终止前等待新任务的最长时间）unit（时间单位）（workQueue）用于在执行任务之前保存任务的队列
        ThreadPoolExecutor tpe = new ThreadPoolExecutor(3,6,50, TimeUnit.MILLISECONDS,bq);
```

###### 线程池参数：

- corePoolSize（核心线程数）
- maximumPoolSize（最大线程数）
- keepAliveTime（线程存活时间）
- unit（时间单位）
- workQueue（队列）

###### 线程池工作过程：

1. 如果运行线程数少于corePoolSize则立刻创建线程
2. 如果运行线程数大于corePoolSize则加入队列
3. 如果队列已满且少于maximumPoolSize则创建非核心线程
4. 如果队列已满且大于maximumPoolSize则抛出拒绝创建线程的异常
5. 在线程执行完后任务会从队列移除，然后继续执行队列的下一个
6. 线程大于maximumPoolSize且空闲时间超过keepAliveTime回收线程

###### 提交任务时线程池队列已满怎么办？

看有没有达到最大线程数，没达到就创建，超过就报异常





# 事务

#### 事务是什么：

是数据库操作的最小单元。

#### 事务的四大特性：

- 原子性：事务的操作要么一起执行要么都不执行
- 一致性：事务执行前后，数据库的一致性不变。必须保证事务的完整执行后的结果
- 持久性：事务一旦提交，那么其对数据的改变就应是永久的
- 隔离性：多个事务之间是互不干扰的

#### 事务的隔离级别：

- read_uncommitted（读未提交）：（不能解决）一个事务可以被允许看到另一个事务未提交的数据。

- read_committed（读已提交）:（解决脏读）一个事务修改完数据后才能被另一个事务读取从而保证一个事务不能读取另一个事务未提交的数据
- repeatable-read（可重复读）：（解决脏读，不可重复读）在read_committed的情况下。又确保了同一事务的多个实例在并发读取数据时，会看到同样的数据行，从而解决了重复读（原理在事务读取到的数据上加锁）
- serlalizable（序列化）：（都解决）

#### 为什么出现事务的隔离级别：

为了解决脏读，幻读，重复读的情况

#### 什么是脏读，幻读，重复读：

- 脏读：当一个事务读取到另一个事务改变前的数据。（解决：read_committed）
- 幻读：当事务前后两次查询（事务中有两次同样的查询操作）时，读取到的数据个数不一样。（解决：在两行记录间空隙加上锁（间隙锁），防止新记录的插入。serlalizable）
- 重复读：当事务前后两次查询（事务中有两次同样的查询操作）时，读取到的数据内容不一样。（解决：当sql第一次读取到数据后就会对这些数据加锁。但无法防止insert数据）

#### 事务的传播行为：

###### 什么是事务的传播行为：

指的就是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行。 

###### 事务传播行为有哪几种：

以以下行为传播（对事务要求程度由大到小）

- PROPAGATION_MANDATORY（propagation_mandatory：必须传播）：方法支持事务。如果当前存在事务则加入，不存在则抛出异常
- PROPAGATION_REQUIRED（propagation_required：需要传播）：方法必须运行在事务中。如果当前事务存在则加入，不存在则新建事务。
- PROPAGATION_REQUIRES_NEW（propagation_required_new需要新建传播）：方法新建事务。无论存不存在事务都新建事务。并且将前面事务挂起。
- PROPAGATION_SUPPORTS（propagation_supports：支持传播）：方法支持事务。如果当前事务存在则加入，不存在则以非事务运行。
- PROPAGATION_NESTED（propagation_nested：嵌套传播）：方法以事务嵌套执行。如果当前存在事务则嵌套，不存在则新建。（外层事务回滚会引起内层事务回滚，内层事务回滚不会影响外层）
- PROPAGATION_NOT_SUPPORTED（propagation_no_supported：不支持传播）：方法以非事务进行执行，如果当前存在事务，就将事务挂起
- PROPAGATION_NEVER（propagation_never：永远不会传播）：方法以非事务进行执行。如果当前存在事务则抛出异常



# mysql

###### mysql是什么：

mysql是一个存储和管理数据的关系数据库（关系数据库：是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。）。

###### mysql的引擎（可在confg文件更改引擎）：

myisam：5.5以前版本，不支持事务，不支持外键，不支持行锁，非聚集索引

innodb（事务型引擎）：支持事务，支持外键，支持行锁，聚集索引



#### 索引

###### 索引是什么：

索引是对数据库一列或多列的值进行排序的一种结构。

###### 索引的功能：

可以快速访问特定数据（优化查询sql的速度）

而提升索引的查找速度的最好办法就是尽可能减少i/o次数。

###### 建立索引的原则：

将经常需要查询，排序，分组，联合操作的字段建立索引。字段尽量设置不为null。索引列上不进行计算。

###### 聚集索引和非聚集索引：

聚集索引（聚簇索引）：数据行的物理顺序与列值（主键那一列）一致，一个表只能有一个聚集索引（b+tree）

非聚集索引：索引的逻辑顺序与物理存储顺序不同，一个表可以有多个非聚集索引

###### 索引的结构

hash索引：

将索引字段的值的哈希值进行排序。

优点：只需要一次检索就可以找到数据，比b+tree快

缺点：

- 需要读行：因为哈希索引不存储字段值，需要进一步通过指针指向内存中的对应行，
- 无法用于排序：哈希索引不是安装索引值的·顺序来存储的，无法用作排序
- 如果有大量重复键值的情况下（哈希碰撞），效率会很低

B+tree（平衡多叉树）索引：

从二叉树一步步优化过来。

在b+树中，有子叶节点和非子叶节点。

非子叶节点保存索引数据，子叶节点保存索引和业务数据。（聚合索引保存一行数据，非聚合索引保存主键）

![20201130155522444](C:\Users\whfch\Pictures\20201130155522444.png)

###### b+tree索引和hash索引有什么区别：

- Hash索引仅仅能满足“=”,“IN”,“<=>”查询，不能使用范围查询
- hash索引无法进行数据排序
- hahs索引遇到大量哈希碰撞，性能不一定比b+tree好

###### 什么情况下会出现索引失效：

- 条件中有or（需要将or条件中每个字段加上索引）
- 多列索引，不使用最左的字段作为搜索条件
- 以%开头的like查询

###### 如何查找索引是否生效

通过explain查看sql语句的执行：如：EXPLAIN SELECT * from sys_menu where 



# 设计模式



# Spring



# 计算机网络









