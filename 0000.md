自我介绍

您好，我叫xxx，来自xxx。











# jvm

jvm是什么：jvm（Java Virtual Machine）java虚拟机

jvm的作用：实现跨平台（将.class文件根据各操作系统对应的jvm编译成字节码在各操作系统运行）

jvm的内存划分：

- 类加载器：负责加载程序中的类
- 执行引擎：执行字节码或本地方法
- 运行时数据区：程序运行时数据区域

类加载器：

​		负责类的加载，不管是否可以运行。

​		查找类过程：启动类加载器----->扩展类加载器----->应用程序类加载器----->用户自定义加载器

​		双亲委派机制：当子类加载器查找类时，会先让父类去查找这个类。（如果一个类加载器收到了加载类的请		求，它会先把请求委托给上层加载器去完成，上层加载器又会委托上上层加载器，一直到最顶层的类加载		器；如果上层加载器无法完成类的加载工作时，当前类加载器才会尝试自己去加载这个类。）

jvm运行时数据区：

- 程序计数器：

  工作过程：（线程私有）字节码解释器通过改变程序计数器的值来依次执行。

  作用：就是让代码顺序执行

- 虚拟机栈：

  工作过程：（线程私有）将java程序的每个方法作为栈帧都放入栈中，代码一行行读取，对应着一次次入栈。代码一行行执行对应这个一次次出栈。方法中的局部变量都会存在这个栈帧中。

  作用：区分每个方法的局部变量。并且让代码顺序执行

  栈帧会出现以下两种异常：

  StackOverFlowError（栈溢出）虚拟机栈的内存不允许动态扩容，当线程请求栈的深度超过虚拟机的最大深度时就会抛出该异常。（如递归死循环）：for(;;)  {method()};

  OutOfMemoryError（内存溢出）又叫oom，引发该异常的原因有两个：堆空间不足，元空间不足。一般由申请空间过大且无法被释放：for(;;)  {int[] tmp=new int[1000000]; list.add(tmp);};

- 本地方法栈：

  类似虚拟机栈，执行的是本地方法（本地方法就是非java代码的接口）。

- 堆：

  工作过程：（线程共享）占用最大资源的一块，所有对象的引用实例以及数组都在这哥区域分配内存

  作用：存储数据

  堆内存主要分为三块：

  新生代：内存满了会进行 minorGC，如果依然不够，会移动到老生代

  老生代：满了会进行FullGC,如果依然内存不够，会出现OOM(OutOfMemoryError)

  永生代（方法区）：1.8已被移除，后为元空间

  由于堆中存储各种内存，所有是主要GC（垃圾收集）的部分

- 元空间：

  作用：存放被虚拟机加载的类信息，常量池

  

  